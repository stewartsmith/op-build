From 427ed8c0b5cbae9cfbeec04623e0354f55f58d8c Mon Sep 17 00:00:00 2001
From: Bill Schwartz <whs@us.ibm.com>
Date: Mon, 25 Jan 2016 10:28:17 -0600
Subject: [PATCH] Adjust ATTR_PEER_TARGET values for runtime

At runtime init, translate ATTR_PEER_TARGET target addresses to runtime values.

Change-Id: I4218bc273090f80f0f9e94985dd2593cadb6c05d
ForwardPort: yes
CQ: SW330305
Reviewed-on: http://gfw160.aus.stglabs.ibm.com:8080/gerrit/23594
Tested-by: Jenkins Server
Tested-by: Jenkins OP Build CI
Tested-by: Jenkins OP HW
Tested-by: FSP CI Jenkins
Reviewed-by: Marshall J. Wilks <mjwilks@us.ibm.com>
Reviewed-by: Daniel M. Crowell <dcrowell@us.ibm.com>
---
 src/include/usr/targeting/common/target.H | 12 ++++-
 src/usr/targeting/runtime/start_rt.C      | 78 ++++++++++++++++++++++++++++++-
 2 files changed, 87 insertions(+), 3 deletions(-)

diff --git a/src/include/usr/targeting/common/target.H b/src/include/usr/targeting/common/target.H
index bf5b7da..1243dee 100644
--- a/src/include/usr/targeting/common/target.H
+++ b/src/include/usr/targeting/common/target.H
@@ -5,7 +5,7 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* Contributors Listed Below - COPYRIGHT 2012,2015                        */
+/* Contributors Listed Below - COPYRIGHT 2012,2016                        */
 /* [+] International Business Machines Corp.                              */
 /*                                                                        */
 /*                                                                        */
@@ -54,6 +54,13 @@
 //******************************************************************************
 // Forward declarations to allow friend functions to work
 //******************************************************************************
+#ifdef __HOSTBOOT_RUNTIME
+namespace RT_TARG
+{
+    void adjustTargeting4Runtime();
+}
+#endif
+
 namespace fapi
 {
     class ReturnCode;
@@ -573,6 +580,9 @@ class Target
         friend class AssociationManager;
         friend class AttributeTank;
 
+#ifdef __HOSTBOOT_RUNTIME
+        friend void RT_TARG::adjustTargeting4Runtime();
+#endif
         // Friend functions to allow FAPI Attribute code to directly call
         // _tryGetAttr and _trySetAttr for code size optimization
         friend fapi::ReturnCode fapi::platAttrSvc::getTargetingAttr(
diff --git a/src/usr/targeting/runtime/start_rt.C b/src/usr/targeting/runtime/start_rt.C
index f56685f..8890c2d 100644
--- a/src/usr/targeting/runtime/start_rt.C
+++ b/src/usr/targeting/runtime/start_rt.C
@@ -5,7 +5,9 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* COPYRIGHT International Business Machines Corp. 2013,2014              */
+/* Contributors Listed Below - COPYRIGHT 2013,2016                        */
+/* [+] International Business Machines Corp.                              */
+/*                                                                        */
 /*                                                                        */
 /* Licensed under the Apache License, Version 2.0 (the "License");        */
 /* you may not use this file except in compliance with the License.       */
@@ -23,9 +25,15 @@
 #include <targeting/common/commontargeting.H>
 #include <targeting/common/targetservice.H>
 #include <targeting/attrrp.H>
+#include <targeting/common/trace.H>
+#include <targeting/common/utilFilter.H>
+
+using namespace TARGETING;
 
-namespace TARGETING
+namespace RT_TARG
 {
+    void adjustTargeting4Runtime();
+
     static void initTargeting() __attribute__((constructor));
     static void initTargeting()
     {
@@ -40,5 +48,71 @@ namespace TARGETING
 
         TargetService& l_targetService = targetService();
         (void)l_targetService.init();
+
+        adjustTargeting4Runtime();
+    }
+
+    // Make any adjustments needed to targeting for runtime
+    void adjustTargeting4Runtime()
+    {
+        TRACDCOMP(g_trac_targeting,"adjustTargeting4Runtime");
+
+        // Loop through all targets and fix those with ATTR_PEER_TARGETs.
+        //
+        // ATTR_PEER_TARGET is the only attribute using the Target_t type.
+        // The value of a Target_t attribute is a Target * "pointer" to
+        // another target. The value is set up by the targeting scripts at
+        // build time. Targeting uses a translate function to nagivate through
+        // the targeting binary. There is a runtime translation function used
+        // at run time to account for the location of the targeting binary
+        // being at a different spot at runtime. The Target_t * value of
+        // the attribute remains pointing into where the targeting binary
+        // was at IPL. Using this "old" address would seg fault at run time.
+        // The value of the ATTR_PEER_TARGET attributes must be translated
+        // for run time.
+        // The _trySetAttr is used directly to avoid the trySetAttr template
+        // error check that ATTR_PEER_TARGET is only readable, not writable.
+        // adjustTargeting4Runtime has been included as a friend to allow
+        // access to the private target class methods.
+        const Target* l_pUnused = NULL;
+        size_t l_xlateCnt = 0;
+        for (TargetIterator target = targetService().begin();
+                target != targetService().end();
+                ++target)
+        {
+            const TARGETING::Target * l_target = *target;
+            TARGETING::Target * l_peer =  static_cast<Target*>(NULL);
+            bool l_hasPeer = l_target->tryGetAttr<ATTR_PEER_TARGET>(l_peer);
+            if (l_hasPeer)
+            {
+                TRACDCOMP(g_trac_targeting,
+                      "translate peer target for=%p %x",
+                      l_target, get_huid(l_target));
+
+                ATTR_PEER_TARGET_type l_xlated = (TARGETING::Target *)
+                                   Singleton<AttrRP>::instance().
+                                   AttrRP::translateAddr(l_peer,l_pUnused);
+                bool l_fixed = false;
+                l_fixed = l_target->_trySetAttr(ATTR_PEER_TARGET,
+                                      sizeof(l_xlated),
+                                      &l_xlated);
+                if (l_fixed)
+                {
+                    TRACDCOMP(g_trac_targeting, "   to=%p", l_xlated);
+                    l_xlateCnt++;
+                }
+                // Not good if could not be fixed. But might not be referenced.
+                // A segment fault will occur if used.
+                else
+                {
+                    TRACFCOMP(g_trac_targeting,
+                        "failed to translate peer target HUID=0x%x",
+                        get_huid(l_target));
+                }
+            }
+        }
+        TRACFCOMP(g_trac_targeting,
+              "adjustTargeting4Runtime: %d peer target addresses translated",
+               l_xlateCnt);
     }
 }
