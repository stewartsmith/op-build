From b983a5a9e38858135aafa62572ae442c39bc2424 Mon Sep 17 00:00:00 2001
From: Dean Sanner <dsanner@us.ibm.com>
Date: Thu, 29 Oct 2015 14:14:04 -0500
Subject: [PATCH] Increase PCIe BAR space for multiple K80 GPUs under single
 PHB

CQ: SW332391
Backport: release-fips840
Backport: release-fips811
Change-Id: I8e76339a0b951e1bbf03cb78417070455d2d31c9
Reviewed-on: http://gfw160.aus.stglabs.ibm.com:8080/gerrit/23309
Tested-by: Jenkins Server
Tested-by: Jenkins OP Build CI
Tested-by: Jenkins OP HW
Tested-by: FSP CI Jenkins
Reviewed-by: Thi N. Tran <thi@us.ibm.com>
Reviewed-by: Daniel M. Crowell <dcrowell@us.ibm.com>
---
 src/include/usr/hwpf/hwp/procMemConsts.H     |  7 +++++--
 src/usr/hwpf/plat/fapiPlatAttributeService.C | 26 +++++++++++++++++++++++---
 2 files changed, 28 insertions(+), 5 deletions(-)

diff --git a/src/include/usr/hwpf/hwp/procMemConsts.H b/src/include/usr/hwpf/hwp/procMemConsts.H
index 5d343b0..df243c7 100644
--- a/src/include/usr/hwpf/hwp/procMemConsts.H
+++ b/src/include/usr/hwpf/hwp/procMemConsts.H
@@ -5,7 +5,9 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* COPYRIGHT International Business Machines Corp. 2012,2014              */
+/* Contributors Listed Below - COPYRIGHT 2012,2016                        */
+/* [+] International Business Machines Corp.                              */
+/*                                                                        */
 /*                                                                        */
 /* Licensed under the Apache License, Version 2.0 (the "License");        */
 /* you may not use this file except in compliance with the License.       */
@@ -55,13 +57,14 @@ const uint64_t  PCI_MEM_SIZE	    =   0x0000001000000000ULL;
 //      Bar1 = 2_GB   ( from spreadsheet)
 //      Bar2 = 4_KB see NOTE above
 const uint64_t  PCIE_BAR0_SIZE      =   0x0000001000000000ULL;
+const uint64_t  PCIE_SAPH_BAR0_SIZE =   0x0000010000000000ULL;  //1TB for K80
 const uint64_t  PCIE_BAR1_SIZE      =   0x0000000080000000ULL;
 const uint64_t  PCIE_BAR2_SIZE      =   0x0000000000001000ULL;
 
 // 4 PHB per chip, 4chips per node, max 4 nodes
 const uint64_t  PCIE_BAR0_OFFSET_MASK =  ((PCIE_BAR0_SIZE*4*4*4)-1);
 const uint64_t  PCIE_BAR1_OFFSET_MASK =  ((PCIE_BAR1_SIZE*4*4*4)-1);
-const uint64_t  SAPPHIRE_PCIE_BAR0_BASE = 0x00003B0000000000;
+const uint64_t  SAPPHIRE_PCIE_BAR0_BASE = 0x0000200000000000; // 32TB for K80
 const uint64_t  SAPPHIRE_PCIE_BAR1_BASE = 0x00003FE000000000;
 
 
diff --git a/src/usr/hwpf/plat/fapiPlatAttributeService.C b/src/usr/hwpf/plat/fapiPlatAttributeService.C
index 7904280..427f996 100644
--- a/src/usr/hwpf/plat/fapiPlatAttributeService.C
+++ b/src/usr/hwpf/plat/fapiPlatAttributeService.C
@@ -5,7 +5,7 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* Contributors Listed Below - COPYRIGHT 2011,2015                        */
+/* Contributors Listed Below - COPYRIGHT 2011,2016                        */
 /* [+] International Business Machines Corp.                              */
 /*                                                                        */
 /*                                                                        */
@@ -1079,6 +1079,7 @@ fapi::ReturnCode fapiPlatGetProcPcieBarBaseAddr (
             // Pull the data out of the Hostboot attribute
             uint64_t l_pciMem32[4];
             uint64_t l_pciMem64[4];
+            uint16_t l_pos;
             l_pProcTarget->tryGetAttr<TARGETING::ATTR_PCI_BASE_ADDRS_32>(
                 l_pciMem32);
             l_pProcTarget->tryGetAttr<TARGETING::ATTR_PCI_BASE_ADDRS_64>(
@@ -1086,6 +1087,7 @@ fapi::ReturnCode fapiPlatGetProcPcieBarBaseAddr (
             uint64_t l_phbRegs[4];
             l_pProcTarget->tryGetAttr<TARGETING::ATTR_PHB_BASE_ADDRS>(
                 l_phbRegs);
+            l_pProcTarget->tryGetAttr<TARGETING::ATTR_POSITION>(l_pos);
 
             //  BAR # 0 are the PCIE mem 64, 64GB window
             //  BAR # 1 are the PCIE mem 32, 2GB window
@@ -1097,6 +1099,15 @@ fapi::ReturnCode fapiPlatGetProcPcieBarBaseAddr (
             //can be supported.  Largest (theoretically dimm) is 1TB,
             //so max mem is ~32TB for non brazos system.
 
+            //For systems that have multiple K80 adapters in it need
+            //to reserve 1TB per PHB.  Given this we will place
+            //mem64 @ 32TB - 64TB range, 1TB per PHB.  Note that
+            //the last TB is also where the mem32 BARs are placed,
+            //but this isn't a problem since Murano/Venice only have
+            // 3 actual BARs (4th is unused), Naples has 4.  Physical
+            //chip wiring on naples prevents more that 2 sockets so
+            //the PHB range on chip 8, bar 4 is never used.
+
             //Place mem64 @ 59TB-63TB (0x00003B0000000000)
             //Place mem32 @ 63.875TB-64TB (0x00030FE000000000)
 
@@ -1110,7 +1121,9 @@ fapi::ReturnCode fapiPlatGetProcPcieBarBaseAddr (
                if(TARGETING::is_sapphire_load())
                {
                    o_pcieBarBase[u][0] = SAPPHIRE_PCIE_BAR0_BASE +
-                                     (l_pciMem64[u] & PCIE_BAR0_OFFSET_MASK);
+                                     (l_pos * PCIE_SAPH_BAR0_SIZE*
+                                      PROC_SETUP_BARS_PCIE_NUM_UNITS) +
+                                     (u * PCIE_SAPH_BAR0_SIZE) ;
                    o_pcieBarBase[u][1] = SAPPHIRE_PCIE_BAR1_BASE +
                                      (l_pciMem32[u] & PCIE_BAR1_OFFSET_MASK);
                }
@@ -1154,7 +1167,14 @@ fapi::ReturnCode fapiPlatGetProcPcieBarSize (
         //  NOTE: only supported BAR2 size is 4KB
         for ( uint8_t u=0; u < PROC_SETUP_BARS_PCIE_NUM_UNITS; u++ )
         {
-           o_pcieBarSize[u][0]  =   PCIE_BAR0_SIZE ;
+           if(TARGETING::is_sapphire_load())
+           {
+               o_pcieBarSize[u][0]  =   PCIE_SAPH_BAR0_SIZE ;
+           }
+           else
+           {
+               o_pcieBarSize[u][0]  =   PCIE_BAR0_SIZE ;
+           }
            o_pcieBarSize[u][1]  =   PCIE_BAR1_SIZE ;
            o_pcieBarSize[u][2]  =   PCIE_BAR2_SIZE;
 
